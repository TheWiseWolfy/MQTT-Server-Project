Index: Model/ClientManager.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from Model.Tools import *\r\nfrom Model.Client import Client\r\nfrom Model.Session import Sesion\r\n\r\n\r\nclass ClientManager:\r\n    clients = dict()\r\n    sessions = dict()\r\n\r\n    def __init__(self):\r\n        pass\r\n\r\n    def applyPachage(self, package, socket):\r\n        # Daca detectam un pachet de tip CONNECT\r\n        # cautam ID-ul clientului sa vedem daca inca mai exista in lista noasta de clienti\r\n        # daca nu exista, cram un client nou, si asamblam pachetul CONNECT\r\n        # pe care il trimitem inapoi tot aici\r\n\r\n        if (package.type == PacketType.CONNECT):\r\n            newClient = None\r\n\r\n            ## CLIENT HANDDLELING ##\r\n\r\n            if package.client_id not in self.clients:\r\n                newClient = Client(package.client_id)\r\n                self.clients[package.client_id] = newClient\r\n            else:\r\n                raise \"this is not allowed buddy\"\r\n\r\n\r\n            ## SESSION HANDDLELING ##\r\n            if package.clearSession:        # Daca clear session este setat pe 1\r\n                if package.client_id in self.sessions:\r\n                    del self.sessions[package.client_id]\r\n\r\n                newSession = Sesion(persistent=False)       #cream o sesiune noua menita sa fie temporara\r\n                self.sessions[package.client_id] = newSession\r\n                newClient.currentSession = newSession\r\n            else:                            # Daca clear session este setat pe 0\r\n                if package.client_id not in self.sessions:       #daca nu exista o sesiune existenta pentru client id-ul curent\r\n\r\n                    newSession = Sesion(persistent=True)        #cream noi o sesiune si o asociem noului client\r\n                    self.sessions[package.client_id] = newSession\r\n                    newClient.currentSession = newSession\r\n                else:                                            #daca exista deja o sesiune, doar o reasociem\r\n                    newClient.currentSession = self.sessions[package.client_id]\r\n\r\n            ##WILL MESSAGE HANDDLELINGN ##\r\n\r\n            if package.will_flag:\r\n                newClient.willFlag = True\r\n                newClient.willMessage = \"I guess someone forgot to implement the actual WILL MESSAGEEEEEEEEEEE\"\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Model/ClientManager.py b/Model/ClientManager.py
--- a/Model/ClientManager.py	(revision 6b90a176581d20ccb91de87cb6b17c012b1e40e3)
+++ b/Model/ClientManager.py	(date 1638479787491)
@@ -1,6 +1,7 @@
 from Model.Tools import *
 from Model.Client import Client
 from Model.Session import Sesion
+from Model.Package import Package
 
 
 class ClientManager:
@@ -10,7 +11,7 @@
     def __init__(self):
         pass
 
-    def applyPachage(self, package, socket):
+    def applyPachage(self, package, mySocket):
         # Daca detectam un pachet de tip CONNECT
         # cautam ID-ul clientului sa vedem daca inca mai exista in lista noasta de clienti
         # daca nu exista, cram un client nou, si asamblam pachetul CONNECT
@@ -18,11 +19,13 @@
 
         if (package.type == PacketType.CONNECT):
             newClient = None
+            sessionAlreadyExisted = False
 
             ## CLIENT HANDDLELING ##
 
             if package.client_id not in self.clients:
                 newClient = Client(package.client_id)
+                newClient.socket = mySocket    #aici asociem fiecare socket cu un client
                 self.clients[package.client_id] = newClient
             else:
                 raise "this is not allowed buddy"
@@ -44,6 +47,7 @@
                     newClient.currentSession = newSession
                 else:                                            #daca exista deja o sesiune, doar o reasociem
                     newClient.currentSession = self.sessions[package.client_id]
+                    sessionAlreadyExisted = True
 
             ##WILL MESSAGE HANDDLELINGN ##
 
@@ -51,3 +55,12 @@
                 newClient.willFlag = True
                 newClient.willMessage = "I guess someone forgot to implement the actual WILL MESSAGEEEEEEEEEEE"
 
+            ## CONNACK ##
+
+            newPackage = Package()
+            newPackage.type = PacketType.CONNACK
+            newPackage.clearSession = package.clearSession #We keep this data in order to form the CONNAK properly
+            newPackage.sessionAlreadyExisted = sessionAlreadyExisted
+            data = newPackage.serialize()
+
+            newClient.socket.send(data)
Index: Model/Client.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n\r\nclass Client:\r\n    clientID = None\r\n\r\n    willFlag = False\r\n    willMessage = \"\"\r\n\r\n    def __init__(self, clientID):\r\n        self.clientID = clientID\r\n        pass\r\n\r\n    def applyPachage(self, Pachage):\r\n        pass\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Model/Client.py b/Model/Client.py
--- a/Model/Client.py	(revision 6b90a176581d20ccb91de87cb6b17c012b1e40e3)
+++ b/Model/Client.py	(date 1638478869740)
@@ -6,6 +6,8 @@
     willFlag = False
     willMessage = ""
 
+    socket = None
+
     def __init__(self, clientID):
         self.clientID = clientID
         pass
Index: Model/Server.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import socket\r\nimport threading\r\nimport select\r\n\r\nfrom Model.Tools import bcol\r\nfrom Model.Package import Package, readPackage\r\nfrom Model.ClientManager import ClientManager\r\n\r\nFORMAT = 'utf-8'\r\n\r\n\r\nclass MQTTServer:\r\n    port = 1883  # Default MQTT Port\r\n\r\n    socketList = list()\r\n    clientManager = None\r\n\r\n    running = False  # The status of the server\r\n\r\n    serverIP = 0  # Ip used by the server\r\n    serverSocket = None  # The socket used for listening to new clients\r\n    serverThread = None\r\n    receiveThread = None\r\n\r\n    def __init__(self):\r\n        # Figure out primary ip of the machine. Will fail if weird network adapters are not turned off.\r\n        hostname = socket.gethostname()\r\n        self.serverIP = socket.gethostbyname(hostname)\r\n\r\n        print(f\"{bcol.OKBLUE}Server has taked IP: {self.serverIP}{bcol.ENDC}\")\r\n\r\n        # Here we format the adress\r\n        self.addr = (self.serverIP, self.port)\r\n\r\n        # Logica interna care manageriaza clienti\r\n        self.clientManager = ClientManager()\r\n\r\n        # Here we bind the socket so we can use it for magic\r\n        try:\r\n            self.serverSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n            self.serverSocket.bind(self.addr)\r\n\r\n            # We need a thread for listening for new connections\r\n            self.serverThread = threading.Thread(target=self.startServer, args=())\r\n            self.serverThread.start()\r\n\r\n            self.receiveThread = threading.Thread(target=self.handleClients, args=())\r\n            self.receiveThread.start()\r\n        except BaseException as err:\r\n            print(f\"{bcol.WARNING} Unexpected {err=}, {type(err)=} is server startup.{bcol.ENDC}\")\r\n            raise\r\n        else:\r\n            print(f\"Server bound on port {self.port} is starting.\")\r\n\r\n            self.running = True\r\n\r\n    def startServer(self):\r\n        # Server starts listenning on port\r\n        try:\r\n            self.serverSocket.listen()\r\n        except BaseException as err:\r\n            print(f\"{bcol.WARNING}Unexpected {err=}, {type(err)=}.Thread is quitting.{bcol.ENDC}\")\r\n            return\r\n\r\n        print(f\"Server is listening on {self.addr}\\n\")\r\n\r\n        # This is the main loop for new clients\r\n        while True:\r\n\r\n            try:\r\n                conn, addr = self.serverSocket.accept()  # This fuction is BLOKING\r\n\r\n                # Here we add a new client\r\n                self.socketList.append(conn)\r\n\r\n            except OSError as err:\r\n                self.running = False\r\n                break  # this case if for quitting the loop once the socket has been closed\r\n            except BaseException as err:\r\n                print(f\"{bcol.WARNING}Unexpected {err=}, {type(err)=} in starting client on adress.{bcol.ENDC}\\n\")\r\n                continue\r\n            else:  # this case runs when no exception has occured\r\n                print(f\"{bcol.OKBLUE}Client on address {addr} successfully started.{bcol.ENDC}\")\r\n\r\n        self.receiveThread.join()\r\n        print(f\"Server has quit.\")\r\n\r\n    def handleClients(self):\r\n\r\n        while self.running:\r\n            if len(self.socketList) == 0:\r\n                continue\r\n\r\n            selectedSockets, _, _ = select.select(self.socketList, [], [], 1)\r\n\r\n            if selectedSockets:\r\n                for mySocket in selectedSockets:\r\n                    data = readPackage(mySocket)\r\n\r\n                    if not data:\r\n                        # cand ajungem aici PRESUPUNEM ca pachetul de disconec a fost primti deja\r\n                        self.socketList.remove(mySocket)\r\n                        mySocket.close()\r\n\r\n                    else:\r\n                        print(data)\r\n                        newPackage = Package()\r\n                        newPackage.deserialize(data)\r\n\r\n                        # this is the final objective\r\n                        self.clientManager.applyPachage(newPackage, socket)\r\n\r\n    # This is not stupid, and actually very smart.\r\n    def serverISKill(self):\r\n        self.serverSocket.close()\r\n\r\n        for client in self.socketList:\r\n            client.close()\r\n        self.running = False\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Model/Server.py b/Model/Server.py
--- a/Model/Server.py	(revision 6b90a176581d20ccb91de87cb6b17c012b1e40e3)
+++ b/Model/Server.py	(date 1638479841694)
@@ -108,7 +108,7 @@
                         newPackage.deserialize(data)
 
                         # this is the final objective
-                        self.clientManager.applyPachage(newPackage, socket)
+                        self.clientManager.applyPachage(newPackage, mySocket)
 
     # This is not stupid, and actually very smart.
     def serverISKill(self):
Index: Model/Package.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\nfrom Model.FixedHeader import ProcessFixedHeader\r\nfrom Model.PacketProcessing import *\r\n\r\n# https://docs.python.org/3/library/struct.html\r\n\r\nclass Package:\r\n    type = None\r\n    dup = False  # Duplicate delivery of a PUBLISH Control Packet\r\n\r\n    QoS = None  # PUBLISH Quality of Service\r\n    retain = False  # PUBLISH Retain flag\r\n\r\n    length = 0\r\n\r\n    packetIdentifier = 0\r\n    client_id = None\r\n\r\n    #Connect\r\n    clearSession = None\r\n    will_flag = None\r\n\r\n    def __init__(self):\r\n        pass\r\n\r\n    def deserialize(self, data):\r\n        self.type = ProcessFixedHeader(data)\r\n\r\n        processPackage(self, self.type, data )\r\n        print(self.QoS)\r\n\r\n    def serialize(self):\r\n        pass\r\n\r\n# This fuction can read a pachage from a socket\r\ndef readPackage(socket):\r\n    packageBites = b''\r\n    packageBites += socket.recv(1024)\r\n\r\n    # if packageBites:\r\n    # remainingLengthOfPackage = lengthDecode(socket)\r\n    # print(f\" The size of the pachage is:{remainingLengthOfPackage}\")\r\n\r\n    # packageBites += socket.recv(remainingLengthOfPackage)\r\n\r\n    return packageBites\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Model/Package.py b/Model/Package.py
--- a/Model/Package.py	(revision 6b90a176581d20ccb91de87cb6b17c012b1e40e3)
+++ b/Model/Package.py	(date 1638479465836)
@@ -1,6 +1,7 @@
 
 from Model.FixedHeader import ProcessFixedHeader
 from Model.PacketProcessing import *
+from Model.PacketFactory import createPackage
 
 # https://docs.python.org/3/library/struct.html
 
@@ -20,17 +21,19 @@
     clearSession = None
     will_flag = None
 
+    #Connak
+    sessionAlreadyExisted = False
+
     def __init__(self):
         pass
 
     def deserialize(self, data):
         self.type = ProcessFixedHeader(data)
-
-        processPackage(self, self.type, data )
-        print(self.QoS)
+        processPackage(self, self.type, data)
 
     def serialize(self):
-        pass
+        return createPackage( self)
+
 
 # This fuction can read a pachage from a socket
 def readPackage(socket):
Index: Model/PacketProcessing.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from Model.Tools import *\r\nfrom struct import *\r\n\r\n\r\ndef processPackage(package, type, data):\r\n    switcher = {\r\n        PacketType.CONNECT: CONNECT,\r\n        PacketType.CONNACK: CONNACK,\r\n        PacketType.PUBLISH: PUBLISH,\r\n        PacketType.PUBACK: PUBACK,\r\n        PacketType.PUBREC: PUBREC,\r\n        PacketType.PUBREL: PUBREL,\r\n        PacketType.PUBCOMP: PUBCOMP,\r\n        PacketType.SUBSCRIBE: SUBSCRIBE,\r\n        PacketType.SUBACK: SUBACK,\r\n        PacketType.UNSUBSCRIBE: UNSUBSCRIBE,\r\n        PacketType.UNSUBACK: UNSUBACK,\r\n        PacketType.PINGREQ: PINGREQ,\r\n        PacketType.PINGRESP: PINGRESP,\r\n        PacketType.DISCONNECT: DISCONNECT,\r\n    }\r\n    func = switcher.get(type)\r\n    return func(package, data)\r\n\r\n\r\ndef CONNECT(package, data):\r\n    formString = 'cccccccccccccc'\r\n\r\n    _, _, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12 = unpack(formString, data[0: 14])\r\n\r\n    if b1 == b'\\x00' and b2 == b'\\x04' and b3 == b'M' and b4 == b'Q' and b5 == b6 == b'T' and b7:\r\n        print(\"\\nAvem un nume protocol CONNECT valid\")\r\n    else:\r\n        print(\"\\n Protocol Name invalid\")\r\n\r\n    if b5 == b'T':\r\n        print(\"\\nAvem un protocol level CONNECT valid\")\r\n    else:\r\n        print(\"\\n Protocol Level invalid\")\r\n    b8_int = int.from_bytes(b8, byteorder='big', signed=False)\r\n    if b8_int & 1 == 0:\r\n        print(\"\\nBitul reserved este 0, and that's good\")\r\n    else:\r\n        print(\"\\nBitul reserved nu este 0, cerem deconectarea clientului\")\r\n\r\n    if b8_int & 2 == 2:\r\n        package.clearSession = True\r\n        print(\"\\nBitul CleanSession este 1\")\r\n    else:\r\n        package.clearSession = False\r\n        print(\"\\nBitul CleanSession este 0\")\r\n\r\n    if b8_int & 4 == 4:\r\n        package.will_flag = True\r\n        print(\"\\nAfisam un Will Message\")\r\n        if b8_int & 32 == 32:\r\n            package.will_retain = True\r\n            print(\"\\nWill Message va fi retinut, will retain=1\")\r\n        else:\r\n            package.will_retain = False\r\n            print(\"\\nWill Message NU va fi retinut, will retain=0\")\r\n    else:\r\n        package.will_flag = False\r\n        package.will_retain = False  # nu stiu daca asa functioneaza randul 509 din documentatie\r\n        print(\"\\nNu afisam un Will Message\")\r\n\r\n    b8_modified = modifyBit(modifyBit(modifyBit(b8_int, 7, 0), 6, 0), 5,\r\n                            0)  # am schimbat in '0' pe 3 cei mai semnificativi biti\r\n    # pentru a verifica mai usor valorile bitilor 4 si 3\r\n\r\n    if b8_modified < 24:\r\n        if b8_modified <= 7:\r\n            print(\"\\nAvem Will QoS=0\")\r\n            package.will_qos = 0\r\n        elif b8_modified <= 15:\r\n            print(\"\\nAvel Will QoS=1\")\r\n            package.will_qos = 1\r\n        elif b8_modified <= 23:\r\n            print(\"\\nAvem Will QoS=2\")\r\n            package.will_qos = 2\r\n    else:\r\n        print(\"\\nWill QoS invalid(=3)\")\r\n\r\n    if b8_int & 128 == 128:\r\n        package.username = True\r\n        print(\"\\nTrebuie sa avem un username in payload\")\r\n    else:\r\n        package.username = False\r\n        package.password = True\r\n        print(\"\\nNU trebuie sa avem un username in payload, implicit nici o parola\")  # nesigur si aici, randul 525\r\n\r\n    if b8_int & 64 == 64:\r\n        package.password = True\r\n        print(\"\\nTrebuie sa avem o parola in payload\")\r\n    else:\r\n        package.password = False\r\n        print(\"\\nNU trebuie sa avem o parola in payload\")\r\n\r\n    package.keep_alive = int.from_bytes(b10 + b9, byteorder='big', signed=False)\r\n    print(\"\\nKeep alive =\", package.keep_alive, \"secunde\")\r\n\r\n    client_id_length = int.from_bytes(b11 + b12, byteorder='big', signed=False)\r\n    fmt = '22c'\r\n    id_tuple = unpack(fmt, data[14:14 + client_id_length])\r\n    package.client_id = \"\"\r\n    for x in id_tuple:\r\n        package.client_id += x.decode(\"utf-8\")\r\n    #main.App.add_element(App, package.client_id)\r\n    package.QoS = 0\r\n\r\ndef CONNACK(data):\r\n    pass\r\n\r\n\r\ndef PUBLISH(data):\r\n    pass\r\n\r\n\r\ndef PUBACK(data):\r\n    pass\r\n\r\n\r\ndef PUBREC(data):\r\n    pass\r\n\r\n\r\ndef PUBREL(data):\r\n    pass\r\n\r\n\r\ndef PUBCOMP(data):\r\n    pass\r\n\r\n\r\ndef SUBSCRIBE(data):\r\n    pass\r\n\r\n\r\ndef SUBACK(data):\r\n    pass\r\n\r\n\r\ndef UNSUBSCRIBE(data):\r\n    pass\r\n\r\n\r\ndef UNSUBACK(data):\r\n    pass\r\n\r\n\r\ndef PINGREQ(data):\r\n    pass\r\n\r\n\r\ndef PINGRESP(data):\r\n    pass\r\n\r\n\r\ndef DISCONNECT(data):\r\n    pass\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Model/PacketProcessing.py b/Model/PacketProcessing.py
--- a/Model/PacketProcessing.py	(revision 6b90a176581d20ccb91de87cb6b17c012b1e40e3)
+++ b/Model/PacketProcessing.py	(date 1638479928407)
@@ -108,53 +108,53 @@
     #main.App.add_element(App, package.client_id)
     package.QoS = 0
 
-def CONNACK(data):
+def CONNACK(package, data):
     pass
 
 
-def PUBLISH(data):
+def PUBLISH(package, data):
     pass
 
 
-def PUBACK(data):
+def PUBACK(package, data):
     pass
 
 
-def PUBREC(data):
+def PUBREC(package, data):
     pass
 
 
-def PUBREL(data):
+def PUBREL(package, data):
     pass
 
 
-def PUBCOMP(data):
+def PUBCOMP(package, data):
     pass
 
 
-def SUBSCRIBE(data):
+def SUBSCRIBE(package, data):
     pass
 
 
-def SUBACK(data):
+def SUBACK(package, data):
     pass
 
 
-def UNSUBSCRIBE(data):
+def UNSUBSCRIBE(package, data):
     pass
 
 
-def UNSUBACK(data):
+def UNSUBACK(package, data):
     pass
 
 
-def PINGREQ(data):
+def PINGREQ(package, data):
     pass
 
 
-def PINGRESP(data):
+def PINGRESP(package, data):
     pass
 
 
-def DISCONNECT(data):
+def DISCONNECT(package, data):
     pass
Index: Model/PacketFactory.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Model/PacketFactory.py b/Model/PacketFactory.py
new file mode 100644
--- /dev/null	(date 1638479678980)
+++ b/Model/PacketFactory.py	(date 1638479678980)
@@ -0,0 +1,21 @@
+import struct
+
+from Model.Tools import *
+from struct import *
+
+
+def createPackage(package):
+    SP = b'\x00'
+    if package.type == PacketType.CONNACK:
+        format = "cccc"
+
+        if package.clearSession:
+            SP = b'\x00'  # If the Server accepts a connection with CleanSession set to 1, the Server MUST set Session Present to 0
+        else:  # If the Server accepts a connection with CleanSession set to 0
+            if package.sessionAlreadyExisted:  # If the Server has stored Session state, it MUST set Session Present to 1
+                SP = b'\x01'
+            else:  # If the Server does not have stored Session state, it MUST set Session Present to 0
+                SP = b'\x00'
+
+        data = struct.pack(format, b'\x20', b'\x02', SP, b'\x00')
+        return data
\ No newline at end of file
