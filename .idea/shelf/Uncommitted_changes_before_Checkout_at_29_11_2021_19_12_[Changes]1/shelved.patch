Index: Model/FixedHeader.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Aici primim bitisori frumosi de la fixed header.\r\ndef ProcessFixedHeader(client):\r\n    fixedHeader = client.socket.recv(8)\r\n\r\n    switcher = {\r\n        b'0001': CONNECT,  # 1\r\n        b'0010': CONNACK,  # 2\r\n        b'0011': PUBLISH,  # 3\r\n        b'0100': PUBACK,  # 4\r\n        b'0101': PUBREC,  # 5\r\n        b'0110': PUBREL,  # 6\r\n        b'0111': PUBCOMP,  # 7\r\n        b'1000': SUBSCRIBE,  # 8\r\n        b'1001': SUBACK,  # 9\r\n        b'1010': UNSUBSCRIBE,  # 10\r\n        b'1011': UNSUBACK,  # 11\r\n        b'1100': PINGREQ,  # 12\r\n        b'1101': PINGRESP,  # 13\r\n        b'1110': DISCONNECT,  # 14\r\n    }\r\n\r\n    func = switcher.get(fixedHeader[0:4], ERROR)  # Here we pick a function for processing the packet type\r\n    func()  # Execute the function\r\n\r\n    return 0\r\n\r\ndef RL_Decode(client):\r\n    res = 0\r\n\r\n    multiplier = 1\r\n    while True:\r\n        bytes = client.socket.recv(8)\r\n        encodedByte = to_int(bytes)\r\n        #print(f\"\\n{encodedByte}\")\r\n\r\n        res += (encodedByte & 127) * multiplier\r\n        multiplier *= 128\r\n        if multiplier > 128 * 128 * 128:\r\n            raise Exception(\"Malformed Remaining Length\")\r\n        if encodedByte & 128 == 0:\r\n            break\r\n    return res\r\n\r\n# def RL_Encode(x):\r\n#     while True:\r\n#         encodedByte = x % 128\r\n#         x = x / 128\r\n#         if x > 0:\r\n#             encodedByte = encodedByte | 128\r\n#         res = encodedByte\r\n#         if x < 0:\r\n#             break\r\n#     return res\r\n\r\n\r\ndef to_int(x):\r\n    enc=x.decode('utf-8')\r\n    aux=128\r\n    res=0\r\n    for i in range(0,8):\r\n        if enc[i]=='1':\r\n            res+=aux\r\n        aux = aux /2\r\n    return int(res)\r\n\r\n\r\n#We do driffrent things based on diffrent types\r\n\r\n\r\ndef ERROR():\r\n    print(\"CONNECT\")\r\n\r\n\r\ndef CONNECT():\r\n    print(\"CONNECT\")\r\n\r\ndef CONNACK():\r\n    print(\"CONNACK\")\r\n\r\n\r\ndef PUBLISH():\r\n    print(\"PUBLISH\")\r\n\r\n\r\ndef PUBACK():\r\n    print(\"PUBACK\")\r\n\r\n\r\ndef PUBREC():\r\n    print(\"PUBREC\")\r\n\r\n\r\ndef PUBREL():\r\n    print(\"PUBREL\")\r\n\r\n\r\ndef PUBCOMP():\r\n    print(\"PUBCOMP\")\r\n\r\n\r\ndef SUBSCRIBE():\r\n    print(\"SUBSCRIBE\")\r\n\r\n\r\ndef SUBACK():\r\n    print(\"SUBACK\")\r\n\r\n\r\ndef UNSUBSCRIBE():\r\n    print(\"UNSUBSCRIBE\")\r\n\r\n\r\ndef UNSUBACK():\r\n    print(\"UNSUBACK\")\r\n\r\n\r\ndef PINGREQ():\r\n    print(\"PINGREQ\")\r\n\r\n\r\ndef PINGRESP():\r\n    print(\"PINGRESP\")\r\n\r\n\r\ndef DISCONNECT():\r\n    print(\"DISCONNECT\")\r\n    return PacketType.DISCONNECT\r\n\r\ndef ValidateZero(fh):\r\n    enc = fh.decode('utf-8')\r\n    if enc != '0000':\r\n        raise HeaderException()\r\n\r\ndef ValidateOne(fh):\r\n    enc = fh.decode('utf-8')\r\n    if enc != '0100':\r\n        raise HeaderException()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Model/FixedHeader.py b/Model/FixedHeader.py
--- a/Model/FixedHeader.py	(revision 3280db0399d39d3d2509fd93e8539b4a8aea6cc4)
+++ b/Model/FixedHeader.py	(date 1638205938128)
@@ -1,6 +1,7 @@
-# Aici primim bitisori frumosi de la fixed header.
-def ProcessFixedHeader(client):
-    fixedHeader = client.socket.recv(8)
+# Posibly redundant
+from Model.Tools import PacketType
+
+def ProcessFixedHeader(data):
 
     switcher = {
         b'0001': CONNECT,  # 1
@@ -19,58 +20,12 @@
         b'1110': DISCONNECT,  # 14
     }
 
-    func = switcher.get(fixedHeader[0:4], ERROR)  # Here we pick a function for processing the packet type
-    func()  # Execute the function
-
-    return 0
-
-def RL_Decode(client):
-    res = 0
-
-    multiplier = 1
-    while True:
-        bytes = client.socket.recv(8)
-        encodedByte = to_int(bytes)
-        #print(f"\n{encodedByte}")
-
-        res += (encodedByte & 127) * multiplier
-        multiplier *= 128
-        if multiplier > 128 * 128 * 128:
-            raise Exception("Malformed Remaining Length")
-        if encodedByte & 128 == 0:
-            break
-    return res
-
-# def RL_Encode(x):
-#     while True:
-#         encodedByte = x % 128
-#         x = x / 128
-#         if x > 0:
-#             encodedByte = encodedByte | 128
-#         res = encodedByte
-#         if x < 0:
-#             break
-#     return res
-
-
-def to_int(x):
-    enc=x.decode('utf-8')
-    aux=128
-    res=0
-    for i in range(0,8):
-        if enc[i]=='1':
-            res+=aux
-        aux = aux /2
-    return int(res)
-
-
-#We do driffrent things based on diffrent types
-
+    func = switcher.get(data[0:4], ERROR)  # Here we pick a function for processing the packet type
+    return func(fixedHeader[4:8]) # Execute the function and return the packet type
 
 def ERROR():
     print("CONNECT")
 
-
 def CONNECT():
     print("CONNECT")
 
@@ -135,3 +90,55 @@
     enc = fh.decode('utf-8')
     if enc != '0100':
         raise HeaderException()
+
+
+def lengthDecode(socket):
+    res = 0
+
+    multiplier = 1
+    while True:
+        bytes = socket.recv(8)
+        encodedByte = to_int(bytes)
+        #print(f"\n{encodedByte}")
+
+        res += (encodedByte & 127) * multiplier
+        multiplier *= 128
+        if multiplier > 128 * 128 * 128:
+            raise Exception("Malformed Remaining Length")
+        if encodedByte & 128 == 0:
+            break
+    return res
+
+
+
+def to_int(x):
+    enc=x.decode('utf-8')
+    aux=128
+    res=0
+    for i in range(0,8):
+        if enc[i]=='1':
+            res+=aux
+        aux = aux /2
+    return int(res)
+
+# def lengthEcode(x):
+#     while True:
+#         encodedByte = x % 128
+#         x = x / 128
+#         if x > 0:
+#             encodedByte = encodedByte | 128
+#         res = encodedByte
+#         if x < 0:
+#             break
+#     return res
+
+#Exceptions
+
+class HeaderException(Exception):
+    def __init__(self, message="Header invalid"):
+        self.message = message
+        super().__init__(self.message)
+
+# Aici primim bitisorii frumosi de la fixed header.
+def ProcessFixedHeader(client):
+    fixedHeader = client.socket.recv(8)
\ No newline at end of file
Index: Model/Tools.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\nclass bcol:\r\n    HEADER = '\\033[95m'\r\n    OKBLUE = '\\033[94m'\r\n    OKCYAN = '\\033[96m'\r\n    OKGREEN = '\\033[92m'\r\n    WARNING = '\\033[93m'\r\n    FAIL = '\\033[91m'\r\n    ENDC = '\\033[0m'\r\n    BOLD = '\\033[1m'\r\n    UNDERLINE = '\\033[4m'\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Model/Tools.py b/Model/Tools.py
--- a/Model/Tools.py	(revision 3280db0399d39d3d2509fd93e8539b4a8aea6cc4)
+++ b/Model/Tools.py	(date 1638205938141)
@@ -1,3 +1,4 @@
+import enum
 
 class bcol:
     HEADER = '\033[95m'
@@ -9,3 +10,19 @@
     ENDC = '\033[0m'
     BOLD = '\033[1m'
     UNDERLINE = '\033[4m'
+
+class PacketType(enum.Enum):
+    CONNECT=1
+    CONNACK=2
+    PUBLISH=3
+    PUBACK=4
+    PUBREC=5
+    PUBREL=6
+    PUBCOMP=7
+    SUBSCRIBE=8
+    SUBACK=9
+    UNSUBSCRIBE=10
+    UNSUBACK=11
+    PINGREQ=12
+    PINGRESP=13
+    DISCONNECT=14
\ No newline at end of file
Index: Model/Server.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import socket\r\nimport threading\r\nimport select\r\n\r\nfrom Model.Client import Client\r\nfrom Model.Tools import bcol\r\n\r\nFORMAT = 'utf-8'\r\nFIXED_HEADER = 16\r\nDISCONNECT_MESSAGE = \"!DISCONNECT\"\r\n\r\n\r\nclass MQTTServer:\r\n    port = 1883  # Default MQTT Port\r\n    # clientList = list()  # A list of connected clients\r\n    socketList = list()\r\n\r\n    running = False  # The status of the server\r\n\r\n    serverIP = 0  # Ip used by the server\r\n    serverSocket = None  # The socket used for listening to new clients\r\n    serverThread = None\r\n    receiveThread = None\r\n\r\n    def __init__(self):\r\n        # Figure out primary ip of the machine. Will fail if weird network adapters are not turned off.\r\n        hostname = socket.gethostname()\r\n        self.serverIP = socket.gethostbyname(hostname)\r\n\r\n        print(f\"{bcol.OKBLUE}Server has taked IP: {self.serverIP}{bcol.ENDC}\")\r\n\r\n        # Here we format the adress\r\n        self.addr = (self.serverIP, self.port)\r\n\r\n        # Here we bind the socket so we can use it for magic\r\n        try:\r\n            self.serverSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n            self.serverSocket.bind(self.addr)\r\n\r\n            # We need a thread for listening for new connections\r\n            self.serverThread = threading.Thread(target=self.startServer)\r\n            self.serverThread.start()\r\n\r\n            self.receiveThread = threading.Thread(target=self.handleClients)\r\n            self.receiveThread.start()\r\n\r\n        except BaseException as err:\r\n            print(f\"{bcol.WARNING} Unexpected {err=}, {type(err)=} is server startup.{bcol.ENDC}\")\r\n            raise\r\n        else:\r\n            print(f\"Server bound on port {self.port} is starting.\")\r\n            self.running = True\r\n\r\n    def startServer(self):\r\n        # Server starts listenning on port\r\n        try:\r\n            self.serverSocket.listen()\r\n        except BaseException as err:\r\n            print(f\"{bcol.WARNING}Unexpected {err=}, {type(err)=}.Thread is quitting.{bcol.ENDC}\")\r\n            return\r\n\r\n        print(f\"Server is listening on {self.addr}\\n\")\r\n\r\n        # This is the main loop for new clients\r\n        while True:\r\n            try:\r\n                conn, addr = self.serverSocket.accept()  # This fuction is BLOKING\r\n\r\n                # Here we add a new client\r\n                newClient = Client(conn, addr)\r\n\r\n                # self.clientList.append(newClient)\r\n                self.socketList.append(conn)\r\n\r\n            except OSError as err:\r\n                self.running = False\r\n                break  # this case if for quitting the loop once the socket has been closed\r\n            except BaseException as err:\r\n                print(f\"{bcol.WARNING}Unexpected {err=}, {type(err)=} in starting client on adress.{bcol.ENDC}\\n\")\r\n                continue\r\n            else:  # this case runs when no exception has occured\r\n                print(f\"{bcol.OKBLUE}Client on address {addr} successfully started.{bcol.ENDC}\")\r\n\r\n        self.receiveThread.join()\r\n        print(f\"Server has quit.\")\r\n\r\n    def handleClients(self):\r\n        while self.running:\r\n            if len(self.socketList) == 0:\r\n                continue\r\n\r\n            selectedSockets, _, _ = select.select(self.socketList, [], [], 1)\r\n            if selectedSockets:\r\n                for socket in selectedSockets:\r\n                    data = socket.recv(1024)\r\n                    if not data:\r\n                        self.socketList.remove(socket)\r\n                        socket.close()\r\n\r\n                    else:\r\n                        print(data)\r\n\r\n    # This is not stupid, and actually very smart.\r\n    def serverISKill(self):\r\n        for client in self.socketList:\r\n            client.close()\r\n\r\n        self.serverSocket.close()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Model/Server.py b/Model/Server.py
--- a/Model/Server.py	(revision 3280db0399d39d3d2509fd93e8539b4a8aea6cc4)
+++ b/Model/Server.py	(date 1638205938157)
@@ -2,13 +2,10 @@
 import threading
 import select
 
-from Model.Client import Client
 from Model.Tools import bcol
+from Model.Package import Package, readPackage
 
 FORMAT = 'utf-8'
-FIXED_HEADER = 16
-DISCONNECT_MESSAGE = "!DISCONNECT"
-
 
 class MQTTServer:
     port = 1883  # Default MQTT Port
@@ -38,12 +35,11 @@
             self.serverSocket.bind(self.addr)
 
             # We need a thread for listening for new connections
-            self.serverThread = threading.Thread(target=self.startServer)
+            self.serverThread = threading.Thread(target=self.startServer,  args=())
             self.serverThread.start()
 
-            self.receiveThread = threading.Thread(target=self.handleClients)
+            self.receiveThread = threading.Thread(target=self.handleClients, args=())
             self.receiveThread.start()
-
         except BaseException as err:
             print(f"{bcol.WARNING} Unexpected {err=}, {type(err)=} is server startup.{bcol.ENDC}")
             raise
@@ -51,6 +47,8 @@
             print(f"Server bound on port {self.port} is starting.")
             self.running = True
 
+
+
     def startServer(self):
         # Server starts listenning on port
         try:
@@ -63,11 +61,12 @@
 
         # This is the main loop for new clients
         while True:
+
             try:
                 conn, addr = self.serverSocket.accept()  # This fuction is BLOKING
 
                 # Here we add a new client
-                newClient = Client(conn, addr)
+               #newClient = Client(conn, addr)
 
                 # self.clientList.append(newClient)
                 self.socketList.append(conn)
@@ -85,20 +84,24 @@
         print(f"Server has quit.")
 
     def handleClients(self):
+
         while self.running:
             if len(self.socketList) == 0:
                 continue
 
             selectedSockets, _, _ = select.select(self.socketList, [], [], 1)
+
             if selectedSockets:
-                for socket in selectedSockets:
-                    data = socket.recv(1024)
+                for mySocket in selectedSockets:
+                    data = readPackage(mySocket)
+
                     if not data:
-                        self.socketList.remove(socket)
-                        socket.close()
+                        self.socketList.remove(mySocket)
+                        mySocket.close()
 
                     else:
                         print(data)
+                        newPackage = Package(data)
 
     # This is not stupid, and actually very smart.
     def serverISKill(self):
Index: Model/Package.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from  Model.Tools  import PacketType\r\n\r\n\r\n# https://docs.python.org/3/library/struct.html\r\n\r\nclass Package:\r\n    type = None\r\n    dup = False # Duplicate delivery of a PUBLISH Control Packet\r\n\r\n    QoS = None # PUBLISH Quality of Service\r\n    retain = False # PUBLISH Retain flag\r\n\r\n    length = 0\r\n\r\n    packetIdentifier =0\r\n    payload = None\r\n\r\n    def __init__(self):\r\n        pass\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Model/Package.py b/Model/Package.py
--- a/Model/Package.py	(revision 3280db0399d39d3d2509fd93e8539b4a8aea6cc4)
+++ b/Model/Package.py	(date 1638205938171)
@@ -1,5 +1,6 @@
-from  Model.Tools  import PacketType
+import struct
 
+from Model.FixedHeader import ProcessFixedHeader, lengthDecode
 
 # https://docs.python.org/3/library/struct.html
 
@@ -15,5 +16,30 @@
     packetIdentifier =0
     payload = None
 
-    def __init__(self):
+    def __init__(self,data):
+        pass
+
+    def deserialize(self, data):
         pass
+
+    def serialize(self):
+        pass
+
+
+#This fuction can read a pachage from a socket
+def readPackage(socket):
+    packageBites = b''
+    packageBites += socket.recv(8)
+
+    if packageBites:
+        remainingLengthOfPackage = lengthDecode(socket)
+        print(f" The size of the pachage is:{remainingLengthOfPackage}")
+
+        packageBites += socket.recv(remainingLengthOfPackage)
+
+    return packageBites
+
+
+
+
+
Index: Model/Client.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from Model.FixedHeader import ProcessFixedHeader, RL_Decode\r\n\r\n\r\nclass Client:\r\n    def __init__(self,conn,addr):\r\n        self.socket = conn\r\n        self.adress = addr\r\n        self.connected = False\r\n        self.thread = None\r\n\r\n    #This is the soul of our app.\r\n    def ReadMQTTPackage(self):\r\n\r\n        print(f\"The fixed header is: {self.socket}\") # Reads 8 bites\r\n        ProcessFixedHeader(self)\r\n\r\n        #Only needs exatly as much as it needs\r\n        remainingLenght = RL_Decode(self)\r\n        print(f\" The size of the pachage is:{remainingLenght}\")\r\n\r\n        restOfPachet = self.socket.recv(remainingLenght)\r\n\r\n        print(f\" The rest of the pachage is:{restOfPachet}\")\r\n        return\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Model/Client.py b/Model/Client.py
--- a/Model/Client.py	(revision 3280db0399d39d3d2509fd93e8539b4a8aea6cc4)
+++ b/Model/Client.py	(date 1638205938184)
@@ -1,26 +1,7 @@
-from Model.FixedHeader import ProcessFixedHeader, RL_Decode
 
 
 class Client:
     def __init__(self,conn,addr):
-        self.socket = conn
-        self.adress = addr
-        self.connected = False
-        self.thread = None
-
-    #This is the soul of our app.
-    def ReadMQTTPackage(self):
-
-        print(f"The fixed header is: {self.socket}") # Reads 8 bites
-        ProcessFixedHeader(self)
-
-        #Only needs exatly as much as it needs
-        remainingLenght = RL_Decode(self)
-        print(f" The size of the pachage is:{remainingLenght}")
-
-        restOfPachet = self.socket.recv(remainingLenght)
-
-        print(f" The rest of the pachage is:{restOfPachet}")
-        return
+        pass
 
 
