Index: Model/FixedHeader.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from Model.Tools import PacketType\r\n\r\nclass HeaderException(Exception):\r\n    def __init__(self, message=\"Header invalid\"):\r\n        self.message = message\r\n        super().__init__(self.message)\r\n\r\n# Aici primim bitisorii frumosi de la fixed header.\r\ndef ProcessFixedHeader(client):\r\n    fixedHeader = client.socket.recv(8)\r\n\r\n    switcher = {\r\n        b'0001': CONNECT,  # 1\r\n        b'0010': CONNACK,  # 2\r\n        b'0011': PUBLISH,  # 3\r\n        b'0100': PUBACK,  # 4\r\n        b'0101': PUBREC,  # 5\r\n        b'0110': PUBREL,  # 6\r\n        b'0111': PUBCOMP,  # 7\r\n        b'1000': SUBSCRIBE,  # 8\r\n        b'1001': SUBACK,  # 9\r\n        b'1010': UNSUBSCRIBE,  # 10\r\n        b'1011': UNSUBACK,  # 11\r\n        b'1100': PINGREQ,  # 12\r\n        b'1101': PINGRESP,  # 13\r\n        b'1110': DISCONNECT,  # 14\r\n    }\r\n\r\n    func = switcher.get(fixedHeader[0:4], ERROR)  # Here we pick a function for processing the packet type\r\n\r\n    return func(fixedHeader[4:8]) # Execute the function and return the packet type\r\n\r\ndef RL_Decode(client):\r\n    res = 0\r\n\r\n    multiplier = 1\r\n    while True:\r\n        bytes = client.socket.recv(8)\r\n        encodedByte = to_int(bytes)\r\n        # print(f\"\\n{encodedByte}\")\r\n\r\n        res += (encodedByte & 127) * multiplier\r\n        multiplier *= 128\r\n        if multiplier > 128 * 128 * 128:\r\n            raise Exception(\"Malformed Remaining Length\")\r\n        if encodedByte & 128 == 0:\r\n            break\r\n    return res\r\n\r\n\r\n# def RL_Encode(x):\r\n#     while True:\r\n#         encodedByte = x % 128\r\n#         x = x / 128\r\n#         if x > 0:\r\n#             encodedByte = encodedByte | 128\r\n#         res = encodedByte\r\n#         if x < 0:\r\n#             break\r\n#     return res\r\n\r\n\r\ndef to_int(x):\r\n    enc = x.decode('utf-8')\r\n    aux = 128\r\n    res = 0\r\n    for i in range(0, 8):\r\n        if enc[i] == '1':\r\n            res += aux\r\n        aux = aux / 2\r\n    return int(res)\r\n\r\n\r\n# We do different things based on different types\r\n\r\n\r\ndef ERROR(fh):\r\n    print(\"ERROR\")\r\n    raise HeaderException()\r\n\r\n\r\ndef CONNECT(fh):\r\n    ValidateZero(fh)\r\n    print(\"CONNECT\")\r\n    return PacketType.CONNECT\r\n\r\n\r\n\r\ndef CONNACK(fh):\r\n    ValidateZero(fh)\r\n    print(\"CONNACK\")\r\n    return PacketType.CONNACK\r\n\r\n\r\ndef PUBLISH(fh):\r\n    ValidateZero(fh)\r\n    print(\"PUBLISH\")\r\n    return PacketType.PUBLISH\r\n\r\n\r\ndef PUBACK(fh):\r\n    ValidateZero(fh)\r\n    print(\"PUBACK\")\r\n    return PacketType.PUBACK\r\n\r\n\r\ndef PUBREC(fh):\r\n    ValidateZero(fh)\r\n    print(\"PUBREC\")\r\n    return PacketType.PUBREC\r\n\r\n\r\ndef PUBREL(fh):\r\n    ValidateOne(fh)\r\n    print(\"PUBREL\")\r\n    return PacketType.PUBREL\r\n\r\ndef PUBCOMP(fh):\r\n    ValidateZero(fh)\r\n    print(\"PUBCOMP\")\r\n    return PacketType.PUBCOMP\r\n\r\ndef SUBSCRIBE(fh):\r\n    ValidateOne(fh)\r\n    print(\"SUBSCRIBE\")\r\n    return PacketType.SUBSCRIBE\r\n\r\ndef SUBACK(fh):\r\n    ValidateZero(fh)\r\n    print(\"SUBACK\")\r\n    return PacketType.SUBACK\r\n\r\ndef UNSUBSCRIBE(fh):\r\n    ValidateOne(fh)\r\n    print(\"UNSUBSCRIBE\")\r\n    return PacketType.UNSUBSCRIBE\r\n\r\ndef UNSUBACK(fh):\r\n    ValidateZero(fh)\r\n    print(\"UNSUBACK\")\r\n    return PacketType.UNSUBACK\r\n\r\ndef PINGREQ(fh):\r\n    ValidateZero(fh)\r\n    print(\"PINGREQ\")\r\n    return PacketType.PINGREQ\r\n\r\ndef PINGRESP(fh):\r\n    ValidateZero(fh)\r\n    print(\"PINGRESP\")\r\n    return PacketType.PINGRESP\r\n\r\ndef DISCONNECT(fh):\r\n    ValidateZero(fh)\r\n    print(\"DISCONNECT\")\r\n    return PacketType.DISCONNECT\r\n\r\ndef ValidateZero(fh):\r\n    enc = fh.decode('utf-8')\r\n    for i in range(0, 4):\r\n        if enc[i] != '0':\r\n            raise HeaderException()\r\n\r\ndef ValidateOne(fh):\r\n    enc = fh.decode('utf-8')\r\n    if enc[0] != '0' and enc[1] != '1' and enc[2] != '0' and enc[3] != '0':\r\n        raise HeaderException()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Model/FixedHeader.py b/Model/FixedHeader.py
--- a/Model/FixedHeader.py	(revision 4836dadc54a5cff6fccd85c42f64db54afc59af4)
+++ b/Model/FixedHeader.py	(date 1638206047770)
@@ -1,11 +1,4 @@
-from Model.Tools import PacketType
-
-class HeaderException(Exception):
-    def __init__(self, message="Header invalid"):
-        self.message = message
-        super().__init__(self.message)
-
-# Aici primim bitisorii frumosi de la fixed header.
+# Aici primim bitisori frumosi de la fixed header.
 def ProcessFixedHeader(client):
     fixedHeader = client.socket.recv(8)
 
@@ -27,8 +20,9 @@
     }
 
     func = switcher.get(fixedHeader[0:4], ERROR)  # Here we pick a function for processing the packet type
+    func()  # Execute the function
 
-    return func(fixedHeader[4:8]) # Execute the function and return the packet type
+    return 0
 
 def RL_Decode(client):
     res = 0
@@ -37,7 +31,7 @@
     while True:
         bytes = client.socket.recv(8)
         encodedByte = to_int(bytes)
-        # print(f"\n{encodedByte}")
+        #print(f"\n{encodedByte}")
 
         res += (encodedByte & 127) * multiplier
         multiplier *= 128
@@ -47,7 +41,6 @@
             break
     return res
 
-
 # def RL_Encode(x):
 #     while True:
 #         encodedByte = x % 128
@@ -61,107 +54,84 @@
 
 
 def to_int(x):
-    enc = x.decode('utf-8')
-    aux = 128
-    res = 0
-    for i in range(0, 8):
-        if enc[i] == '1':
-            res += aux
-        aux = aux / 2
+    enc=x.decode('utf-8')
+    aux=128
+    res=0
+    for i in range(0,8):
+        if enc[i]=='1':
+            res+=aux
+        aux = aux /2
     return int(res)
 
 
-# We do different things based on different types
-
+#We do driffrent things based on diffrent types
 
-def ERROR(fh):
-    print("ERROR")
-    raise HeaderException()
 
-
-def CONNECT(fh):
-    ValidateZero(fh)
+def ERROR():
     print("CONNECT")
-    return PacketType.CONNECT
 
 
+def CONNECT():
+    print("CONNECT")
 
-def CONNACK(fh):
-    ValidateZero(fh)
+def CONNACK():
     print("CONNACK")
-    return PacketType.CONNACK
 
 
-def PUBLISH(fh):
-    ValidateZero(fh)
+def PUBLISH():
     print("PUBLISH")
-    return PacketType.PUBLISH
 
 
-def PUBACK(fh):
-    ValidateZero(fh)
+def PUBACK():
     print("PUBACK")
-    return PacketType.PUBACK
 
 
-def PUBREC(fh):
-    ValidateZero(fh)
+def PUBREC():
     print("PUBREC")
-    return PacketType.PUBREC
 
 
-def PUBREL(fh):
-    ValidateOne(fh)
+def PUBREL():
     print("PUBREL")
-    return PacketType.PUBREL
 
-def PUBCOMP(fh):
-    ValidateZero(fh)
+
+def PUBCOMP():
     print("PUBCOMP")
-    return PacketType.PUBCOMP
 
-def SUBSCRIBE(fh):
-    ValidateOne(fh)
+
+def SUBSCRIBE():
     print("SUBSCRIBE")
-    return PacketType.SUBSCRIBE
 
-def SUBACK(fh):
-    ValidateZero(fh)
+
+def SUBACK():
     print("SUBACK")
-    return PacketType.SUBACK
 
-def UNSUBSCRIBE(fh):
-    ValidateOne(fh)
+
+def UNSUBSCRIBE():
     print("UNSUBSCRIBE")
-    return PacketType.UNSUBSCRIBE
 
-def UNSUBACK(fh):
-    ValidateZero(fh)
+
+def UNSUBACK():
     print("UNSUBACK")
-    return PacketType.UNSUBACK
 
-def PINGREQ(fh):
-    ValidateZero(fh)
+
+def PINGREQ():
     print("PINGREQ")
-    return PacketType.PINGREQ
 
-def PINGRESP(fh):
-    ValidateZero(fh)
+
+def PINGRESP():
     print("PINGRESP")
-    return PacketType.PINGRESP
 
-def DISCONNECT(fh):
-    ValidateZero(fh)
+
+def DISCONNECT():
     print("DISCONNECT")
     return PacketType.DISCONNECT
 
 def ValidateZero(fh):
     enc = fh.decode('utf-8')
-    for i in range(0, 4):
-        if enc[i] != '0':
-            raise HeaderException()
+    if enc != '0000':
+        raise HeaderException()
 
 def ValidateOne(fh):
     enc = fh.decode('utf-8')
-    if enc[0] != '0' and enc[1] != '1' and enc[2] != '0' and enc[3] != '0':
+    if enc != '0100':
         raise HeaderException()
Index: Model/Client.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from Model.FixedHeader import ProcessFixedHeader, RL_Decode\r\nfrom Model.PacketProcessing import ToProcess\r\n\r\nclass Client:\r\n    def __init__(self,conn,addr):\r\n        self.socket = conn\r\n        self.adress = addr\r\n        self.connected = False\r\n        self.thread = None\r\n\r\n    #This is the soul of our app.\r\n    def ReadMQTTPackage(self):\r\n\r\n        print(f\"The fixed header is: {self.socket}\") # Reads 8 bites\r\n        type=ProcessFixedHeader(self)\r\n\r\n        #Only needs exactly as much as it needs\r\n        remainingLength = RL_Decode(self)\r\n        print(f\" The size of the pachage is:{remainingLength}\")\r\n\r\n        restOfPacket = self.socket.recv(remainingLength)\r\n\r\n        print(f\" The rest of the pachage is:{restOfPacket}\")\r\n        ToProcess(self,type,restOfPacket)\r\n        return\r\n\r\n    def Disconnect(self):\r\n        print(\"\\nDeconectam pe domnu client\")\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Model/Client.py b/Model/Client.py
--- a/Model/Client.py	(revision 4836dadc54a5cff6fccd85c42f64db54afc59af4)
+++ b/Model/Client.py	(date 1638206063078)
@@ -1,29 +1,7 @@
-from Model.FixedHeader import ProcessFixedHeader, RL_Decode
-from Model.PacketProcessing import ToProcess
+
 
 class Client:
     def __init__(self,conn,addr):
-        self.socket = conn
-        self.adress = addr
-        self.connected = False
-        self.thread = None
-
-    #This is the soul of our app.
-    def ReadMQTTPackage(self):
+        pass
 
-        print(f"The fixed header is: {self.socket}") # Reads 8 bites
-        type=ProcessFixedHeader(self)
-
-        #Only needs exactly as much as it needs
-        remainingLength = RL_Decode(self)
-        print(f" The size of the pachage is:{remainingLength}")
-
-        restOfPacket = self.socket.recv(remainingLength)
-
-        print(f" The rest of the pachage is:{restOfPacket}")
-        ToProcess(self,type,restOfPacket)
-        return
-
-    def Disconnect(self):
-        print("\nDeconectam pe domnu client")
 
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.10 (MQTT-Server-Project) (2)\" project-jdk-type=\"Python SDK\" />\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision 4836dadc54a5cff6fccd85c42f64db54afc59af4)
+++ b/.idea/misc.xml	(date 1638206121305)
@@ -1,4 +1,4 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.10 (MQTT-Server-Project) (2)" project-jdk-type="Python SDK" />
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.9 (MQTT-Server-Project)" project-jdk-type="Python SDK" />
 </project>
\ No newline at end of file
Index: Model/Server.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import socket\r\nimport threading\r\nimport select\r\n\r\nfrom Model.Client import Client\r\nfrom Model.Tools import bcol\r\n\r\nFORMAT = 'utf-8'\r\nFIXED_HEADER = 16\r\nDISCONNECT_MESSAGE = \"!DISCONNECT\"\r\n\r\n\r\nclass MQTTServer:\r\n    port = 1883  # Default MQTT Port\r\n    # clientList = list()  # A list of connected clients\r\n    socketList = list()\r\n\r\n    running = False  # The status of the server\r\n\r\n    serverIP = 0  # Ip used by the server\r\n    serverSocket = None  # The socket used for listening to new clients\r\n    serverThread = None\r\n    receiveThread = None\r\n\r\n    def __init__(self):\r\n        # Figure out primary ip of the machine. Will fail if weird network adapters are not turned off.\r\n        hostname = socket.gethostname()\r\n        self.serverIP = socket.gethostbyname(hostname)\r\n\r\n        print(f\"{bcol.OKBLUE}Server has taked IP: {self.serverIP}{bcol.ENDC}\")\r\n\r\n        # Here we format the adress\r\n        self.addr = (self.serverIP, self.port)\r\n\r\n        # Here we bind the socket so we can use it for magic\r\n        try:\r\n            self.serverSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n            self.serverSocket.bind(self.addr)\r\n\r\n            # We need a thread for listening for new connections\r\n            self.serverThread = threading.Thread(target=self.startServer)\r\n            self.serverThread.start()\r\n\r\n            self.receiveThread = threading.Thread(target=self.handleClients)\r\n            self.receiveThread.start()\r\n\r\n        except BaseException as err:\r\n            print(f\"{bcol.WARNING} Unexpected {err=}, {type(err)=} is server startup.{bcol.ENDC}\")\r\n            raise\r\n        else:\r\n            print(f\"Server bound on port {self.port} is starting.\")\r\n            self.running = True\r\n\r\n    def startServer(self):\r\n        # Server starts listenning on port\r\n        try:\r\n            self.serverSocket.listen()\r\n        except BaseException as err:\r\n            print(f\"{bcol.WARNING}Unexpected {err=}, {type(err)=}.Thread is quitting.{bcol.ENDC}\")\r\n            return\r\n\r\n        print(f\"Server is listening on {self.addr}\\n\")\r\n\r\n        # This is the main loop for new clients\r\n        while True:\r\n            try:\r\n                conn, addr = self.serverSocket.accept()  # This fuction is BLOKING\r\n\r\n                # Here we add a new client\r\n                newClient = Client(conn, addr)\r\n\r\n                # self.clientList.append(newClient)\r\n                self.socketList.append(conn)\r\n\r\n            except OSError as err:\r\n                self.running = False\r\n                break  # this case if for quitting the loop once the socket has been closed\r\n            except BaseException as err:\r\n                print(f\"{bcol.WARNING}Unexpected {err=}, {type(err)=} in starting client on adress.{bcol.ENDC}\\n\")\r\n                continue\r\n            else:  # this case runs when no exception has occured\r\n                print(f\"{bcol.OKBLUE}Client on address {addr} successfully started.{bcol.ENDC}\")\r\n\r\n        self.receiveThread.join()\r\n        print(f\"Server has quit.\")\r\n\r\n    def handleClients(self):\r\n        while self.running:\r\n            if len(self.socketList) == 0:\r\n                continue\r\n\r\n            selectedSockets, _, _ = select.select(self.socketList, [], [], 1)\r\n            if selectedSockets:\r\n                for socket in selectedSockets:\r\n                    data = socket.recv(1024)\r\n                    if not data:\r\n                        self.socketList.remove(socket)\r\n                        socket.close()\r\n\r\n                    else:\r\n                        print(data)\r\n\r\n    # This is not stupid, and actually very smart.\r\n    def serverISKill(self):\r\n        for client in self.socketList:\r\n            client.close()\r\n\r\n        self.serverSocket.close()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Model/Server.py b/Model/Server.py
--- a/Model/Server.py	(revision 4836dadc54a5cff6fccd85c42f64db54afc59af4)
+++ b/Model/Server.py	(date 1638206120716)
@@ -2,13 +2,10 @@
 import threading
 import select
 
-from Model.Client import Client
-from Model.Tools import bcol
+from Model.Tools import bcolors
+from Model.Package import Package, readPackage
 
 FORMAT = 'utf-8'
-FIXED_HEADER = 16
-DISCONNECT_MESSAGE = "!DISCONNECT"
-
 
 class MQTTServer:
     port = 1883  # Default MQTT Port
@@ -38,12 +35,11 @@
             self.serverSocket.bind(self.addr)
 
             # We need a thread for listening for new connections
-            self.serverThread = threading.Thread(target=self.startServer)
+            self.serverThread = threading.Thread(target=self.startServer,  args=())
             self.serverThread.start()
 
-            self.receiveThread = threading.Thread(target=self.handleClients)
+            self.receiveThread = threading.Thread(target=self.handleClients, args=())
             self.receiveThread.start()
-
         except BaseException as err:
             print(f"{bcol.WARNING} Unexpected {err=}, {type(err)=} is server startup.{bcol.ENDC}")
             raise
@@ -51,6 +47,8 @@
             print(f"Server bound on port {self.port} is starting.")
             self.running = True
 
+
+
     def startServer(self):
         # Server starts listenning on port
         try:
@@ -63,11 +61,12 @@
 
         # This is the main loop for new clients
         while True:
+
             try:
                 conn, addr = self.serverSocket.accept()  # This fuction is BLOKING
 
                 # Here we add a new client
-                newClient = Client(conn, addr)
+               #newClient = Client(conn, addr)
 
                 # self.clientList.append(newClient)
                 self.socketList.append(conn)
@@ -85,20 +84,24 @@
         print(f"Server has quit.")
 
     def handleClients(self):
+
         while self.running:
             if len(self.socketList) == 0:
                 continue
 
             selectedSockets, _, _ = select.select(self.socketList, [], [], 1)
+
             if selectedSockets:
-                for socket in selectedSockets:
-                    data = socket.recv(1024)
+                for mySocket in selectedSockets:
+                    data = readPackage(mySocket)
+
                     if not data:
-                        self.socketList.remove(socket)
-                        socket.close()
+                        self.socketList.remove(mySocket)
+                        mySocket.close()
 
                     else:
                         print(data)
+                        newPackage = Package(data)
 
     # This is not stupid, and actually very smart.
     def serverISKill(self):
Index: .idea/MQTT-Server-Project.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"PYTHON_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\">\r\n    <content url=\"file://$MODULE_DIR$\">\r\n      <excludeFolder url=\"file://$MODULE_DIR$/venv\" />\r\n      <excludeFolder url=\"file://$MODULE_DIR$/petrisor\" />\r\n    </content>\r\n    <orderEntry type=\"jdk\" jdkName=\"Python 3.10 (MQTT-Server-Project) (2)\" jdkType=\"Python SDK\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/MQTT-Server-Project.iml b/.idea/MQTT-Server-Project.iml
--- a/.idea/MQTT-Server-Project.iml	(revision 4836dadc54a5cff6fccd85c42f64db54afc59af4)
+++ b/.idea/MQTT-Server-Project.iml	(date 1638206121285)
@@ -5,7 +5,7 @@
       <excludeFolder url="file://$MODULE_DIR$/venv" />
       <excludeFolder url="file://$MODULE_DIR$/petrisor" />
     </content>
-    <orderEntry type="jdk" jdkName="Python 3.10 (MQTT-Server-Project) (2)" jdkType="Python SDK" />
+    <orderEntry type="jdk" jdkName="Python 3.9 (MQTT-Server-Project)" jdkType="Python SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
   </component>
 </module>
\ No newline at end of file
Index: Model/Package.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from  Model.Tools  import PacketType\r\n\r\n\r\n# https://docs.python.org/3/library/struct.html\r\n\r\nclass Package:\r\n    type = None\r\n    dup = False # Duplicate delivery of a PUBLISH Control Packet\r\n\r\n    QoS = None # PUBLISH Quality of Service\r\n    retain = False # PUBLISH Retain flag\r\n\r\n    length = 0\r\n\r\n    packetIdentifier =0\r\n    payload = None\r\n\r\n    def __init__(self):\r\n        pass\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Model/Package.py b/Model/Package.py
--- a/Model/Package.py	(revision 4836dadc54a5cff6fccd85c42f64db54afc59af4)
+++ b/Model/Package.py	(date 1638206054884)
@@ -1,5 +1,6 @@
-from  Model.Tools  import PacketType
+import struct
 
+from Model.FixedHeader import ProcessFixedHeader, lengthDecode
 
 # https://docs.python.org/3/library/struct.html
 
@@ -15,5 +16,30 @@
     packetIdentifier =0
     payload = None
 
-    def __init__(self):
+    def __init__(self,data):
+        pass
+
+    def deserialize(self, data):
         pass
+
+    def serialize(self):
+        pass
+
+
+#This fuction can read a pachage from a socket
+def readPackage(socket):
+    packageBites = b''
+    packageBites += socket.recv(8)
+
+    if packageBites:
+        remainingLengthOfPackage = lengthDecode(socket)
+        print(f" The size of the pachage is:{remainingLengthOfPackage}")
+
+        packageBites += socket.recv(remainingLengthOfPackage)
+
+    return packageBites
+
+
+
+
+
